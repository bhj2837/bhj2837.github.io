---
title: "브루트 포스 (Brute Force) - 1"
date: 2025-12-02 18:00:00 +0900
categories: [Algorithm Basics, Brute Force]
tags: [algorithm, brute-force, selection-sort, bubble-sort, sorting]
math: true
---

## 브루트 포스(Brute Force)란?

**브루트 포스(Brute Force)**는 "무차별 대입" 또는 "완전 탐색"으로 불리는 알고리즘 설계 기법이다. 

### 핵심 개념

> **"Just do it!"** - 문제의 정의를 그대로 따라가는 가장 직관적인 방법

브루트 포스는 문제 설명과 관련 개념의 정의에 **직접적으로 기반**한 straightforward한 접근 방식이다. 복잡한 최적화 없이 가능한 모든 경우를 시도하거나, 정의를 그대로 구현하는 것이 특징이다.

### 브루트 포스의 예시

1. **거듭제곱 계산** ($$a^n$$, a > 0, n은 음이 아닌 정수)
   - 1을 a로 n번 곱하기

2. **팩토리얼 계산** (n!)
   - 1부터 n까지 모든 수를 곱하기

3. **최대공약수(GCD)** 계산
   - 연속된 정수를 확인하는 알고리즘

4. **행렬 곱셈**
   - 정의대로 각 원소를 계산

5. **리스트에서 값 탐색**
   - 처음부터 끝까지 순차적으로 확인

## 왜 브루트 포스가 중요한가?

효율적이지 않은데도 브루트 포스를 배워야 하는 이유:

### 1. 광범위한 적용 가능성

브루트 포스는 **매우 다양한 문제**에 적용할 수 있다. 문제의 정의만 명확하다면 거의 모든 문제에 브루트 포스 접근이 가능하다.

### 2. 실용적 가치

일부 중요한 문제들의 경우, 브루트 포스가 **인스턴스 크기에 제한 없이** 합리적인 알고리즘을 제공한다.

예시: 정렬, 탐색, 행렬 곱셈, 문자열 매칭 등

### 3. 비용 대비 효율성

문제의 일부 인스턴스만 해결하면 되고, 브루트 포스로 **수용 가능한 속도**로 해결할 수 있다면, 더 효율적인 알고리즘을 설계하는 비용이 정당화되지 않을 수 있다.

### 4. 작은 입력에서의 효용성

일반적으로는 비효율적이더라도, **작은 크기의 인스턴스**를 해결하는 데는 여전히 유용할 수 있다.

### 5. 비교 기준(Yardstick) 역할

브루트 포스는 더 효율적인 대안을 **판단하는 기준**으로 중요한 이론적, 교육적 목적을 제공한다.

> "이 알고리즘이 브루트 포스보다 얼마나 빠른가?"

## 선택 정렬(Selection Sort)

선택 정렬은 브루트 포스 방식의 대표적인 정렬 알고리즘이다.

### 기본 아이디어

1. 배열 전체에서 **가장 작은 값**을 찾는다
2. 찾은 값을 **첫 번째 위치**와 교환한다
3. 두 번째 원소부터 시작하여 나머지 배열에서 가장 작은 값을 찾는다
4. 찾은 값을 **두 번째 위치**와 교환한다
5. 이 과정을 n-1번 반복한다

### 알고리즘 의사코드

```
ALGORITHM SelectionSort(A[0..n-1])
    // 주어진 배열을 선택 정렬로 정렬
    // Input: 정렬 가능한 원소들의 배열 A[0..n-1]
    // Output: 오름차순으로 정렬된 배열 A[0..n-1]
    
    for i ← 0 to n-2 do
        min ← i
        for j ← i+1 to n-1 do
            if A[j] < A[min]
                min ← j
        swap A[i] and A[min]
```

### C++ 구현

```cpp
#include <vector>
#include <iostream>
using namespace std;

void selectionSort(vector<int>& arr) {
    int n = arr.size();
    
    // i번째 위치에 올 최솟값 찾기
    for (int i = 0; i < n - 1; i++) {
        int minIdx = i;  // 최솟값의 인덱스
        
        // i+1부터 끝까지 최솟값 찾기
        for (int j = i + 1; j < n; j++) {
            if (arr[j] < arr[minIdx]) {
                minIdx = j;
            }
        }
        
        // 최솟값을 i번째 위치와 교환
        swap(arr[i], arr[minIdx]);
    }
}

// 출력 함수
void printArray(const vector<int>& arr) {
    for (int num : arr) {
        cout << num << " ";
    }
    cout << endl;
}
```

### 동작 과정 예시

**배열 [89, 45, 68, 90, 29, 34, 17]을 정렬해보자:**

```
초기 상태: [89, 45, 68, 90, 29, 34, 17]

Pass 1 (i=0):
  최솟값 17 찾음 (인덱스 6)
  89와 17 교환
  결과: [17 | 45, 68, 90, 29, 34, 89]
        └─┘
       정렬됨

Pass 2 (i=1):
  최솟값 29 찾음 (인덱스 4)
  45와 29 교환
  결과: [17, 29 | 68, 90, 45, 34, 89]
        └────┘
        정렬됨

Pass 3 (i=2):
  최솟값 34 찾음 (인덱스 5)
  68와 34 교환
  결과: [17, 29, 34 | 90, 45, 68, 89]
        └────────┘
         정렬됨

Pass 4 (i=3):
  최솟값 45 찾음 (인덱스 4)
  90와 45 교환
  결과: [17, 29, 34, 45 | 68, 89, 90]
        └──────────────┘
          정렬됨

Pass 5 (i=4):
  최솟값 68 (이미 제자리)
  교환 없음
  결과: [17, 29, 34, 45, 68 | 89, 90]

Pass 6 (i=5):
  최솟값 89 (이미 제자리)
  교환 없음
  결과: [17, 29, 34, 45, 68, 89 | 90]

최종: [17, 29, 34, 45, 68, 89, 90]
```

### 시간 복잡도 분석

**비교 횟수 계산:**

외부 루프가 i = 0부터 n-2까지 실행되고, 각 i에 대해 내부 루프가 실행된다:

$$
\begin{align}
C(n) &= \sum_{i=0}^{n-2} \sum_{j=i+1}^{n-1} 1 \\
&= \sum_{i=0}^{n-2} [(n-1) - (i+1) + 1] \\
&= \sum_{i=0}^{n-2} (n-1-i) \\
&= (n-1) + (n-2) + \cdots + 2 + 1 \\
&= \frac{(n-1)n}{2}
\end{align}
$$

**결과:**
- 비교 횟수: $\frac{(n-1)n}{2} = \frac{n^2 - n}{2}$
- 시간 복잡도: **Θ(n²)** (모든 경우에 동일)

**교환 횟수:**
- 정확히 **n-1번** (각 pass마다 1번씩)
- 입력 데이터와 무관하게 항상 동일

### 선택 정렬의 특징

**장점:**
1. **구현이 간단**하다
2. **교환 횟수가 적다** - 메모리 쓰기 비용이 큰 경우 유리
3. **In-place 정렬** - 추가 메모리 불필요 (O(1) 공간)

**단점:**
1. **항상 O(n²)** - 이미 정렬된 경우에도 느리다
2. **불안정 정렬** - 같은 값의 상대적 순서가 바뀔 수 있다
   - 예: `[3a, 2, 3b, 1]` → `[1, 2, 3b, 3a]` (3a와 3b 순서 바뀜)

## 버블 정렬(Bubble Sort)

버블 정렬은 인접한 원소들을 비교하며 정렬하는 브루트 포스 알고리즘이다.

### 기본 아이디어

1. **인접한 두 원소**를 비교한다
2. 순서가 잘못되어 있으면 **교환**한다
3. 배열을 처음부터 끝까지 이 과정을 반복하면 가장 큰 값이 맨 뒤로 "bubble up"된다
4. 다음 pass에서는 두 번째로 큰 값이 뒤에서 두 번째로 이동한다
5. n-1번의 pass 후 배열이 정렬된다

### 알고리즘 의사코드

```
ALGORITHM BubbleSort(A[0..n-1])
    // 주어진 배열을 버블 정렬로 정렬
    // Input: 정렬 가능한 원소들의 배열 A[0..n-1]
    // Output: 오름차순으로 정렬된 배열 A[0..n-1]
    
    for i ← 0 to n-2 do
        for j ← 0 to n-2-i do
            if A[j+1] < A[j]
                swap A[j] and A[j+1]
```

### C++ 구현

```cpp
#include <vector>
#include <iostream>
using namespace std;

void bubbleSort(vector<int>& arr) {
    int n = arr.size();
    
    // n-1번의 pass
    for (int i = 0; i < n - 1; i++) {
        // 인접한 원소들을 비교
        for (int j = 0; j < n - 1 - i; j++) {
            // 순서가 잘못되어 있으면 교환
            if (arr[j] > arr[j + 1]) {
                swap(arr[j], arr[j + 1]);
            }
        }
    }
}
```

### 동작 과정 예시

**배열 [89, 45, 68, 90, 29, 34, 17]을 정렬해보자:**

```
초기: [89, 45, 68, 90, 29, 34, 17]

Pass 1: 가장 큰 값(90)을 맨 뒤로
  89 ↔ 45: [45, 89, 68, 90, 29, 34, 17]
  89 ↔ 68: [45, 68, 89, 90, 29, 34, 17]
  90 유지:  [45, 68, 89, 90, 29, 34, 17]
  90 ↔ 29: [45, 68, 89, 29, 90, 34, 17]
  90 ↔ 34: [45, 68, 89, 29, 34, 90, 17]
  90 ↔ 17: [45, 68, 89, 29, 34, 17, 90]
           └────────────────────┘  └─┘
                정렬 안 됨        정렬됨

Pass 2: 두 번째로 큰 값(89)을 뒤에서 두 번째로
  45 ↔ 68: [45, 68, 89, 29, 34, 17 | 90]
  89 ↔ 29: [45, 68, 29, 89, 34, 17 | 90]
  89 ↔ 34: [45, 68, 29, 34, 89, 17 | 90]
  89 ↔ 17: [45, 68, 29, 34, 17, 89 | 90]
           └──────────────────┘  └────┘
               정렬 안 됨         정렬됨

Pass 3: 세 번째로 큰 값(68)을 정렬
  [45, 68, 29, 34, 17 | 89, 90]
  → [45, 29, 34, 17, 68 | 89, 90]

...

최종: [17, 29, 34, 45, 68, 89, 90]
```

### 시간 복잡도 분석

**비교 횟수:**

선택 정렬과 동일한 계산:

$$
C(n) = \sum_{i=0}^{n-2} \sum_{j=0}^{n-2-i} 1 = \frac{(n-1)n}{2}
$$

**교환 횟수:**
- **최선의 경우** (이미 정렬됨): 0번
- **최악의 경우** (역순 정렬): 비교 횟수와 동일 $\frac{(n-1)n}{2}$
- **평균**: 약 $\frac{(n-1)n}{4}$

**시간 복잡도:**
- 최선: **O(n)** (최적화 버전에서, 이미 정렬된 경우)
- 평균: **O(n²)**
- 최악: **O(n²)**

### 버블 정렬 최적화

**조기 종료(Early Termination):**

한 번의 pass에서 **교환이 전혀 발생하지 않으면**, 배열이 이미 정렬되어 있다는 의미이므로 알고리즘을 종료할 수 있다.

```cpp
if (!swapped) break;  // 교환이 없었으면 종료
```

이 최적화로 최선의 경우 **O(n)** 시간 복잡도를 달성할 수 있다.

## 선택 정렬 vs 버블 정렬

### 비교표

| 특성 | Selection Sort | Bubble Sort |
|-----|---------------|-------------|
| **비교 횟수** | $\frac{(n-1)n}{2}$ | $\frac{(n-1)n}{2}$ |
| **교환 횟수 (최선)** | n-1 | 0 |
| **교환 횟수 (최악)** | n-1 | $\frac{(n-1)n}{2}$ |
| **시간 복잡도** | Θ(n²) | Θ(n²) |
| **최적화 가능** | 불가능 | 가능 (조기 종료) |
| **안정성** | 불안정 | 안정 |
| **공간 복잡도** | O(1) | O(1) |

### 주요 차이점

**1. 교환 횟수**
- **선택 정렬**: 항상 n-1번 (최소한의 교환)
- **버블 정렬**: 0 ~ $\frac{(n-1)n}{2}$번 (입력에 따라 다름)

**2. 최적화 가능성**
- **선택 정렬**: 항상 모든 원소를 비교해야 함
- **버블 정렬**: 이미 정렬된 경우 조기 종료 가능

**3. 안정성**
- **선택 정렬**: 불안정 (같은 값의 순서가 바뀔 수 있음)
- **버블 정렬**: 안정 (같은 값의 순서 유지)

### 언제 무엇을 사용할까?

**선택 정렬을 선택:**
- 메모리 쓰기 비용이 큰 경우
- 교환 횟수를 최소화해야 하는 경우

**버블 정렬을 선택:**
- 거의 정렬된 데이터
- 안정 정렬이 필요한 경우

**둘 다 피해야 할 경우:**
- 큰 데이터셋 (둘 다 O(n²)로 느림)
- 대신 병합 정렬, 퀵 정렬 등 O(n log n) 알고리즘 사용