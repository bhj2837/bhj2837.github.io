---
title: "완전 탐색 (Exhaustive Search): TSP, 배낭 문제, 할당 문제"
date: 2025-12-11 18:00:00 +0900
categories: [Brute Force, Exhaustive Search]
tags: [exhaustive-search, tsp, knapsack, assignment, brute-force, permutation, subset]
math: true
---

## Exhaustive Search란?

Exhaustive Search(완전 탐색)는 **조합 문제(combinatorial problems)**에 적용하는 브루트 포스 방법이다.

여기서 조합 문제란, 명시적이든 암묵적이든 특정 **제약 조건(constraints)**을 만족하는 **조합적 객체(combinatorial object)**—순열, 조합, 부분집합 등—를 찾아야 하는 문제를 말한다. 이런 문제 중 많은 경우가 **최적화 문제(optimization problems)**이기도 하다. 경로 길이나 비용 같은 값을 최대화 또는 최소화하는 원소를 찾아야 하는 것들이 그 예다.

Exhaustive Search의 핵심 아이디어는 단순하다.

1. **Generate**: 문제의 모든 조합적 객체를 생성한다
2. **Select**: 제약 조건을 만족하는 것들을 선별한다
3. **Find**: 그 중에서 원하는 객체(최적해)를 찾는다

### 핵심 기법: 순열 열거 vs 부분집합 열거

Exhaustive Search의 핵심 기법은 결국 두 가지다.

- **순열(permutation) 열거**: 원소들의 모든 순서 나열 → $O(n!)$
- **부분집합(subset) 열거**: 원소들의 모든 선택 조합 → $O(2^n)$

이 챕터에서 다루는 세 문제—TSP, 배낭 문제, 할당 문제—는 이 두 기법을 조합 최적화 문제에 적용한 고전적인 예시들이다. 

---

## 1. 외판원 문제 (Traveling Salesman Problem, TSP)

### 문제 정의

$n$개의 도시가 있을 때, **모든 도시를 정확히 한 번씩 방문하고 출발 도시로 돌아오는 가장 짧은 경로**를 구하는 문제다.

이 문제는 **가중치 그래프(weighted graph)**로 모델링할 수 있다. 정점은 도시, 간선의 가중치는 도시 간 거리를 나타낸다. 즉, 가중치가 있는 완전 연결 그래프에서 최단 해밀토니안 회로(Hamiltonian circuit)를 찾는 문제이기도 하다.

> **해밀토니안 회로(Hamiltonian circuit)**: 그래프의 모든 정점을 정확히 한 번씩 지나는 사이클. $n+1$개의 인접한 정점 수열 $v_{i_0}, v_{i_1}, \ldots, v_{i_{n-1}}, v_{i_0}$로 표현하며, 첫 정점과 마지막 정점이 같고 나머지 $n-1$개 정점은 모두 다르다.

### Exhaustive Search 적용

4개의 도시 a, b, c, d가 있는 다음 그래프를 생각해보자.

```
     a ---2--- b
     |  \   / |
     5   8 7  3
     |    X   |
     c ---1--- d
```

간선 가중치: a-b=2, a-c=5, a-d=7, b-c=8, b-d=3, c-d=1

도시 a를 출발점으로 고정하면, 나머지 3개 도시의 순열이 곧 가능한 모든 투어다.

| 투어 | 경로 길이 |
|------|-----------|
| a → b → c → d → a | 2+8+1+7 = 18 |
| **a → b → d → c → a** | **2+3+1+5 = 11 (최적)** |
| a → c → b → d → a | 5+8+3+7 = 23 |
| **a → c → d → b → a** | **5+1+3+2 = 11 (최적)** |
| a → d → b → c → a | 7+3+8+5 = 23 |
| a → d → c → b → a | 7+1+8+2 = 18 |

최적 투어는 길이 11이며, 두 가지 경로가 존재한다 (방향만 반대).

### 복잡도 분석

출발점을 고정하면 나머지 $(n-1)$개 도시의 순열을 모두 탐색해야 한다. 그런데 위 예시처럼 방향만 반대인 투어 쌍이 항상 존재하므로 실제 고유한 투어 수는 다음과 같다.

$$\frac{1}{2}(n-1)!$$

$n=10$이면 약 181,440개, $n=20$이면 약 $6 \times 10^{16}$개로 폭발적으로 증가한다. 이 때문에 Exhaustive Search는 $n$이 아주 작은 경우에만 현실적으로 적용 가능하다.

### C++ 구현

```cpp
#include <bits/stdc++.h>
using namespace std;

int n; // 도시 수
int dist[10][10]; // 거리 행렬

int tsp() {
    vector<int> cities;
    for (int i = 1; i < n; i++) cities.push_back(i); // 0번 도시를 출발점으로 고정

    int minCost = INT_MAX;

    do {
        int cost = 0;
        int cur = 0;

        for (int next : cities) {
            cost += dist[cur][next];
            cur = next;
        }
        cost += dist[cur][0]; // 출발점으로 복귀

        minCost = min(minCost, cost);
    } while (next_permutation(cities.begin(), cities.end()));

    return minCost;
}

int main() {
    // 슬라이드 예시 (a=0, b=1, c=2, d=3)
    n = 4;
    int d[4][4] = {
        {0, 2, 5, 7},
        {2, 0, 8, 3},
        {5, 8, 0, 1},
        {7, 3, 1, 0}
    };
    for (int i = 0; i < n; i++)
        for (int j = 0; j < n; j++)
            dist[i][j] = d[i][j];

    cout << "최단 투어 길이: " << tsp() << endl; // 11
    return 0;
}
```

`next_permutation`을 사용해 나머지 도시들의 모든 순열을 순서대로 생성하고, 각 순열마다 총 거리를 계산해 최솟값을 갱신한다.

---

## 2. 배낭 문제 (Knapsack Problem)

### 문제 정의

무게 $w_1, w_2, \ldots, w_n$과 가치 $v_1, v_2, \ldots, v_n$을 가진 $n$개의 아이템과 용량 $W$인 배낭이 주어질 때, 배낭에 넣을 수 있는 아이템의 가장 가치 있는 부분집합을 구하는 문제다.

### Exhaustive Search 적용

다음 4개의 아이템과 용량 W=10인 배낭을 생각해보자.

| 아이템 | 무게 | 가치 |
|--------|------|------|
| 1 | 7 | $42 |
| 2 | 3 | $12 |
| 3 | 4 | $40 |
| 4 | 5 | $25 |

4개 아이템의 모든 부분집합($2^4 = 16$가지)을 열거한다.

| 부분집합 | 총 무게 | 총 가치 |
|----------|---------|---------|
| ∅ | 0 | $0 |
| {1} | 7 | $42 |
| {2} | 3 | $12 |
| {3} | 4 | $40 |
| {4} | 5 | $25 |
| {1,2} | 10 | $54 |
| {1,3} | 11 | 불가 |
| {1,4} | 12 | 불가 |
| {2,3} | 7 | $52 |
| {2,4} | 8 | $37 |
| **{3,4}** | **9** | **$65** |
| {1,2,3} | 14 | 불가 |
| {1,2,4} | 15 | 불가 |
| {1,3,4} | 16 | 불가 |
| {2,3,4} | 12 | 불가 |
| {1,2,3,4} | 19 | 불가 |

총 무게가 10을 초과하는 부분집합(불가)을 제외하면, 최적해는 {3,4}로 총 무게 9, 총 가치 **$65**이다.

### 복잡도 분석

$n$개 아이템의 부분집합 수는 $2^n$이므로, Exhaustive Search는 $\Omega(2^n)$ 알고리즘이다. 마찬가지로 $n$이 조금만 커져도 실용적이지 않다. (배낭 문제는 이후 DP로 $O(nW)$에 풀 수 있다.)

### C++ 구현

```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
    int n = 4, W = 10;
    int w[] = {7, 3, 4, 5};
    int v[] = {42, 12, 40, 25};

    int maxVal = 0;
    int bestSubset = 0;

    // 비트마스킹으로 모든 부분집합 열거
    for (int mask = 0; mask < (1 << n); mask++) {
        int totalW = 0, totalV = 0;

        for (int i = 0; i < n; i++) {
            if (mask & (1 << i)) { // i번째 아이템 선택
                totalW += w[i];
                totalV += v[i];
            }
        }

        if (totalW <= W && totalV > maxVal) {
            maxVal = totalV;
            bestSubset = mask;
        }
    }

    cout << "최대 가치: $" << maxVal << endl;
    cout << "선택한 아이템: ";
    for (int i = 0; i < n; i++)
        if (bestSubset & (1 << i))
            cout << i + 1 << " ";
    cout << endl;
    // 최대 가치: $65, 선택한 아이템: 3 4

    return 0;
}
```

비트마스킹을 활용해 0부터 $2^n - 1$까지의 정수를 순서대로 순회하며, 각 비트를 아이템 포함 여부로 해석한다. 직관적이고 구현이 간단하다.

---

## 3. 할당 문제 (Assignment Problem)

### 문제 정의

$n$명의 사람을 $n$개의 작업에 배정해야 한다. 한 작업에 한 명만 배정할 수 있고, 사람 $i$를 작업 $j$에 배정하는 비용은 $C[i, j]$로 주어진다. 총 비용이 최소인 배정을 구하는 문제다.

이 문제는 비용 행렬의 각 행에서 원소를 하나씩 선택하되, 선택된 원소들이 모두 다른 열에 위치해야 하고 선택된 원소들의 합이 최소가 되어야 한다.

"각 행에서 가장 작은 값을 선택"하는 탐욕적 방법은 통하지 않는다. 같은 열을 중복 선택할 수 있기 때문이다.

### Exhaustive Search 적용

4명의 사람과 4개의 작업, 다음 비용 행렬을 생각해보자.

$$C = \begin{bmatrix} 9 & 2 & 7 & 8 \\ 6 & 4 & 3 & 7 \\ 5 & 8 & 1 & 8 \\ 7 & 6 & 9 & 4 \end{bmatrix}$$

배정은 $n$-튜플 $\langle j_1, j_2, j_3, j_4 \rangle$으로 표현한다. $i$번째 성분은 $i$번째 사람에게 배정된 작업 번호를 의미한다. 예를 들어 $\langle 2, 3, 4, 1 \rangle$은 사람1→작업2, 사람2→작업3, 사람3→작업4, 사람4→작업1을 의미한다.

$(1, 2, 3, 4)$의 모든 순열을 열거하면 다음과 같다 (앞부분만).

| 배정 | 총 비용 |
|------|---------|
| ⟨1, 2, 3, 4⟩ | 9+4+1+4 = 18 |
| ⟨1, 2, 4, 3⟩ | 9+4+8+9 = 30 |
| ⟨1, 3, 2, 4⟩ | 9+3+8+4 = 24 |
| ⟨1, 3, 4, 2⟩ | 9+3+8+6 = 26 |
| ⟨1, 4, 2, 3⟩ | 9+7+8+9 = 33 |
| ⟨1, 4, 3, 2⟩ | 9+7+1+6 = 23 |
| ... | ... |

$4! = 24$개의 모든 순열을 탐색해 최솟값을 찾으면, 최적 배정은 $\langle 2, 3, 4, 1 \rangle$로 **총 비용 13**이다. (사람1→작업2($2), 사람2→작업3($3), 사람3→작업1($5), 사람4→작업4($4) → 합계 13 ... 실제 최적해는 모든 순열을 돌려봐야 확인 가능)

### 복잡도 분석

$n$개의 순열 수는 $n!$이므로, Exhaustive Search는 $O(n!)$ 알고리즘이다. TSP와 마찬가지로 $n$이 커질수록 빠르게 한계에 부딪힌다. (할당 문제는 이후 헝가리안 알고리즘으로 $O(n^3)$에 풀 수 있다.)

### C++ 구현

```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
    int n = 4;
    int C[4][4] = {
        {9, 2, 7, 8},
        {6, 4, 3, 7},
        {5, 8, 1, 8},
        {7, 6, 9, 4}
    };

    vector<int> jobs = {0, 1, 2, 3}; // 작업 인덱스 (0-indexed)
    int minCost = INT_MAX;
    vector<int> bestAssign;

    do {
        int cost = 0;
        for (int i = 0; i < n; i++)
            cost += C[i][jobs[i]];

        if (cost < minCost) {
            minCost = cost;
            bestAssign = jobs;
        }
    } while (next_permutation(jobs.begin(), jobs.end()));

    cout << "최소 비용: " << minCost << endl;
    cout << "배정: ";
    for (int i = 0; i < n; i++)
        cout << "사람" << i+1 << "→작업" << bestAssign[i]+1 << " ";
    cout << endl;

    return 0;
}
```

`next_permutation`으로 작업 번호의 모든 순열을 생성하고, 각 순열을 배정으로 해석해 총 비용을 계산한다.

---

## 정리 및 비교

| 문제 | 탐색 대상 | 복잡도 | 핵심 기법 |
|------|-----------|--------|-----------|
| TSP | 도시 방문 순열 | $\frac{1}{2}(n-1)!$ | 순열 열거 |
| 배낭 문제 | 아이템 부분집합 | $\Omega(2^n)$ | 부분집합 열거 |
| 할당 문제 | 작업 배정 순열 | $O(n!)$ | 순열 열거 |

세 문제 모두 Exhaustive Search로는 $n$이 조금만 커져도 현실적으로 풀 수 없다. 하지만 이 접근법은 정확한 해를 보장하며, 더 효율적인 알고리즘의 정확성 검증 기준으로 활용할 수 있다.

이 문제들은 이후 배울 알고리즘들에서도 계속 등장한다.

- **배낭 문제** → 동적 프로그래밍(DP)으로 $O(nW)$
- **TSP** → 백트래킹, 분기한정법으로 개선
- **할당 문제** → 헝가리안 알고리즘으로 $O(n^3)$

