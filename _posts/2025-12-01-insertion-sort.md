---
title: "점진적 접근법 - 삽입 정렬"
date: 2025-12-01 18:00:00 +0900
categories: [Algorithm Basics, Sorting]
tags: [algorithm, insertion-sort, sorting, incremental-approach]
math: true
---

## 점진적 접근법(Incremental Approach)이란?

**점진적 접근법**은 문제를 한 번에 해결하는 것이 아니라, 작은 부분 문제부터 시작해서 점진적으로 확장하며 전체 문제를 해결하는 알고리즘 설계 기법이다.

삽입 정렬(Insertion Sort)은 이러한 점진적 접근법을 가장 잘 보여주는 대표적인 예시다.

## 삽입 정렬(Insertion Sort)

### 기본 아이디어

카드를 정렬하는 상황을 가정:
1. 첫 번째 카드는 이미 정렬되어 있다
2. 두 번째 카드를 첫 번째 카드와 비교해서 올바른 위치에 삽입한다
3. 세 번째 카드를 이미 정렬된 두 카드 사이의 올바른 위치에 삽입한다
4. 이 과정을 모든 카드에 대해 반복한다

**핵심:** 매 단계마다 "지금까지 본 카드들은 정렬되어 있다"는 상태를 유지한다.

### 알고리즘 의사코드

```
Insertion Sort(a₁, a₂, a₃, ..., aₙ)
1. for j ← 2 to n
2.     key ← aⱼ
3.     i ← j - 1
4.     while (i > 0 and aᵢ > key)
5.         aᵢ₊₁ ← aᵢ
6.         i ← i - 1
7.     aᵢ₊₁ ← key
```

### C++ 구현

```cpp
#include <vector>
#include <iostream>
using namespace std;

void insertionSort(vector<int>& arr) {
    int n = arr.size();
    
    // j는 2부터 시작 (인덱스 1)
    for (int j = 1; j < n; j++) {
        int key = arr[j];  // 현재 삽입할 값
        int i = j - 1;     // 정렬된 부분의 마지막 인덱스
        
        // key보다 큰 값들을 오른쪽으로 이동
        while (i >= 0 && arr[i] > key) {
            arr[i + 1] = arr[i];
            i--;
        }
        
        // key를 올바른 위치에 삽입
        arr[i + 1] = key;
    }
}
```

## 동작 과정 예시

**배열 [5, -1, 1, 3]을 정렬해보자:**

### 초기 상태
```
a1=5, a2=-1, a3=1, a4=3
```

### 1st 반복 (j=2, key=-1, i=1)

```
정렬 전: [5, -1, 1, 3]
         ↑   ↑
       정렬됨 key

- i=1, a[1]=5 > key=-1 (조건 만족)
- a[2] ← a[1]: [5, 5, 1, 3]
- i=0
- i=0이므로 while 종료
- a[1] ← key: [-1, 5, 1, 3]

결과: [-1, 5, 1, 3]
     └────┘
    정렬된 부분
```

### 2nd 반복 (j=3, key=1, i=2)

```
정렬 전: [-1, 5, 1, 3]
         └────┘  ↑
        정렬됨   key

- i=2, a[2]=5 > key=1 (조건 만족)
- a[3] ← a[2]: [-1, 5, 5, 3]
- i=1
- i=1, a[1]=-1 < key=1 (조건 불만족)
- while 종료
- a[2] ← key: [-1, 1, 5, 3]

결과: [-1, 1, 5, 3]
     └────────┘
      정렬된 부분
```

### 3rd 반복 (j=4, key=3, i=3)

```
정렬 전: [-1, 1, 5, 3]
         └────────┘  ↑
          정렬됨    key

- i=3, a[3]=5 > key=3 (조건 만족)
- a[4] ← a[3]: [-1, 1, 5, 5]
- i=2
- i=2, a[2]=1 < key=3 (조건 불만족)
- while 종료
- a[3] ← key: [-1, 1, 3, 5]

최종 결과: [-1, 1, 3, 5]
```

## 알고리즘 분석

### 실행 횟수 분석

**Line 1 ~ Line 7이 n-1번 반복된다.**

각 반복에서:
- Line 2 (key 할당): 1번 실행
- Line 3 (i 초기화): 1번 실행
- Line 4~6 (while 루프): 데이터에 따라 다름
- Line 7 (key 삽입): 1번 실행

**핵심은 Line 4~6의 while 루프 반복 횟수다.**

### 시간 복잡도

#### Best Case (최선의 경우)

**이미 정렬된 배열:** `[1, 2, 3, 4]`

```cpp
// 각 반복마다
while (i >= 0 && arr[i] > key)  // 조건이 항상 false
```

- while 루프가 한 번도 실행되지 않음
- 각 반복당 상수 시간
- **시간 복잡도: O(n)**

#### Worst Case (최악의 경우)

**역순으로 정렬된 배열:** `[4, 3, 2, 1]`

```
j=2일 때: while 1번 실행
j=3일 때: while 2번 실행
j=4일 때: while 3번 실행
...
j=n일 때: while (n-1)번 실행
```

총 실행 횟수:
$$1 + 2 + 3 + ... + (n-1) = \frac{n(n-1)}{2} = \frac{n^2 - n}{2}$$

- **시간 복잡도: O(n²)**

#### Average Case (평균의 경우)

평균적으로 while 루프는 절반 정도 실행된다.

- **시간 복잡도: O(n²)**

### 공간 복잡도

```cpp
int key;  // 상수 개의 변수만 사용
int i;
```

- 추가 배열을 사용하지 않음 (In-place 정렬)
- **공간 복잡도: O(1)**

## 삽입 정렬의 특징

### 장점

1. **구현이 간단하다**
   - 코드가 직관적이고 이해하기 쉽다

2. **안정 정렬(Stable Sort)**
   - 같은 값의 상대적 순서가 유지된다
   - 예: `[3a, 1, 3b, 2]` → `[1, 2, 3a, 3b]`

3. **In-place 정렬**
   - 추가 메모리가 거의 필요 없다

4. **작은 데이터셋에서 효율적**
   - 데이터가 10~20개 이하면 빠르다

5. **거의 정렬된 데이터에 효율적**
   - 이미 정렬된 경우 O(n)으로 매우 빠르다

### 단점

1. **큰 데이터셋에서 비효율적**
   - O(n²) 시간 복잡도로 느리다

2. **역순 데이터에 매우 느리다**
   - 최악의 경우 모든 요소를 이동해야 함

## 다른 정렬 알고리즘과의 비교

| 알고리즘 | 최선 | 평균 | 최악 | 공간 | 안정성 |
|---------|------|------|------|------|--------|
| 삽입 정렬 | O(n) | O(n²) | O(n²) | O(1) | 안정 |
| 버블 정렬 | O(n) | O(n²) | O(n²) | O(1) | 안정 |
| 선택 정렬 | O(n²) | O(n²) | O(n²) | O(1) | 불안정 |
| 병합 정렬 | O(n log n) | O(n log n) | O(n log n) | O(n) | 안정 |
| 퀵 정렬 | O(n log n) | O(n log n) | O(n²) | O(log n) | 불안정 |

## 실전 활용

### 삽입 정렬이 사용되는 경우

1. **데이터가 거의 정렬되어 있을 때**
   - 새로운 데이터 몇 개를 이미 정렬된 리스트에 추가할 때

2. **데이터 크기가 작을 때**
   - 고급 정렬 알고리즘의 오버헤드가 더 클 수 있음

3. **온라인 알고리즘이 필요할 때**
   - 데이터가 실시간으로 들어올 때 바로바로 정렬 가능

4. **안정 정렬이 필요할 때**
   - 같은 값의 순서를 유지해야 하는 경우

### 하이브리드 정렬에서의 활용

고급 정렬 알고리즘(예: Timsort, Introsort)에서 **작은 부분 배열**에 대해 삽입 정렬을 사용된다.

```cpp
void hybridSort(vector<int>& arr, int left, int right) {
    // 크기가 작으면 삽입 정렬 사용
    if (right - left < 10) {
        insertionSort(arr, left, right);
    } else {
        // 큰 배열은 퀵 정렬이나 병합 정렬 사용
        quickSort(arr, left, right);
    }
}
```
<div>
